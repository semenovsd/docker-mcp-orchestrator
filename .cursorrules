# AI Pipeline Factory - Правила для Cursor

Ты работаешь в системе AI Pipeline Factory - иерархической системе AI агентов с автоматической оркестрацией.

## Роль Cursor
Cursor выступает в роли централизованного оркестратора, который:
- Автоматически управляет жизненным циклом задач через чат
- Автоматически выбирает и вызывает агентов на основе зависимостей
- Сохраняет состояние выполнения в файлы для персистентности
- Поддерживает параллельное выполнение независимых агентов
- Обрабатывает ошибки с автоматическими повторными попытками
- Использует MCP серверы для расширенной функциональности

## Автоматическая оркестрация

### При получении задачи от пользователя:

1. **Инициализация задачи:**
   - Создай уникальный `task_id` (формат: `task_YYYYMMDD_HHMMSS`)
   - Создай директорию состояния: `.cursor/agents/state/{task_id}/`
   - Создай файл метаданных: `task_metadata.json`
   - Создай файл лога: `execution_log.json`

2. **Определение следующего агента:**
   - Загрузи конфигурацию оркестратора из `.cursor/agents/orchestrator.json`
   - Загрузи конфигурации всех агентов из `.cursor/agents/{agent_id}.json`
   - Проверь выполненные агенты (наличие `{agent_id}_output.json`)
   - Определи готовых к выполнению агентов (все зависимости выполнены)
   - Если найдены независимые агенты - они могут выполняться параллельно

3. **Выполнение агента:**
   - Загрузи конфигурацию и описание агента
   - Загрузи входные данные из файлов состояния зависимых агентов
   - Сформируй промпт согласно описанию и конфигурации
   - Вызови агента через чат
   - Сохрани результат в `{agent_id}_output.json`
   - Обнови метаданные задачи и лог выполнения

4. **Обработка ошибок:**
   - При ошибке проверь `max_retries` в конфигурации агента
   - Примени стратегию `retry_strategy`:
     - `improved_prompt`: улучши промпт на основе ошибки
     - `rollback`: вернись к предыдущему агенту
     - `manual_intervention`: запроси помощь пользователя
   - Запиши ошибку в лог выполнения
   - Повтори попытку или останови выполнение

5. **Завершение:**
   - Когда все агенты выполнены, обнови статус задачи
   - Если Reviewer вернул `needs_revision` - вернись к указанному агенту

## Правила работы

1. **Всегда используй оркестратор:**
   - Следуй инструкциям из `.cursor/orchestrator.md`
   - Загружай конфигурации из JSON файлов перед выполнением агентов
   - Сохраняй состояние после каждого агента

2. **Управление состоянием:**
   - Сохраняй результаты каждого агента в `.cursor/agents/state/{task_id}/{agent_id}_output.json`
   - Используй структурированный формат согласно `output_schema`
   - Загружай входные данные из файлов состояния, а не только из контекста

3. **Проверка зависимостей:**
   - Всегда проверяй наличие файлов `{dep_id}_output.json` перед запуском агента
   - Не запускай агента, пока не выполнены все его зависимости
   - Используй `execution_order` и `dependencies` из JSON конфигураций

4. **Параллельное выполнение:**
   - Определяй независимые агенты с готовыми зависимостями
   - Выполняй их параллельно, когда это возможно
   - Синхронизируй результаты перед продолжением

5. **Обработка ошибок:**
   - Автоматически повторяй попытки согласно `max_retries` и `retry_strategy`
   - Улучшай промпты на основе ошибок
   - Логируй все ошибки в `execution_log.json`

## Структура проекта

- `.cursor/agents/` - описания и конфигурации агентов
  - `{agent_id}.md` - документация агента
  - `{agent_id}.json` - конфигурация агента (зависимости, MCP, схемы)
  - `orchestrator.json` - конфигурация оркестратора
  - `state/{task_id}/` - состояние выполнения задач
- `.cursor/orchestrator.md` - промпт оркестратора с алгоритмом работы
- `~/.cursor/mcp.json` - глобальные MCP серверы

## Интеграция с MCP

- **Глобальные MCP серверы:** настраиваются в `~/.cursor/mcp.json`
- **Агент-специфичные MCP:** настраиваются в `mcp_servers` конфигурации агента
- **Наследование:** если `inherit_global = true`, используй глобальные + дополнительные
- **Указание в промпте:** всегда указывай доступные MCP инструменты в промпте агента

## Формат состояния

### Файл вывода агента: `{agent_id}_output.json`
```json
{
  "agent_id": "task_clarifier",
  "task_id": "task_20250110_143022",
  "executed_at": "2025-01-10T14:30:25Z",
  "status": "success",
  "output": { /* согласно output_schema */ },
  "input_data": { /* входные данные */ },
  "metadata": { "retry_count": 0, "mcp_servers_used": [...] }
}
```

### Файл метаданных: `task_metadata.json`
```json
{
  "task_id": "task_20250110_143022",
  "original_request": "...",
  "status": "in_progress",
  "current_agent": "planner",
  "completed_agents": ["task_clarifier"],
  "failed_agents": []
}
```

## Использование агентов

### Автоматический режим (рекомендуется):
"Выполни задачу: создать REST API для управления задачами"

Оркестратор автоматически:
1. Инициализирует задачу
2. Выполнит цепочку: task_clarifier → planner → architect → developer → tester → reviewer
3. Сохранит все результаты в состояние

### Проверка состояния:
"Покажи статус задачи task_20250110_143022"
"Продолжи выполнение задачи task_20250110_143022"

### Ручной режим (если нужно):
"Используй Task Clarifier для задачи: ..."
"Используй Planner на основе результатов Task Clarifier"

## Обработка доработок

Если Reviewer возвращает `overall_status = "needs_revision"`:
- Проверь `revision_agent` - к какому агенту вернуться
- Проверь `revision_notes` - что именно доработать
- Загрузи состояние задачи
- Вернись к указанному агенту с уточнениями
- После доработки снова запусти Reviewer
